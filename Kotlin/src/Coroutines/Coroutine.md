# 동시성 프로그래밍

프로그래밍에서 순서대로 작업을 순행하여 1개의 루틴을 완료한 후 다른 루틴을 실행하는 방식을 동기적으로 수행한다고 한다. 현재의 프로그래밍은 순차적인 프로그램보다 다양한 기능이 한꺼번에 일어나는 다중 실행 환경에 있는 경우가 많다. 여러개의 루틴이 선행 작업의 순서나 완료 여부와 상관없이 실행되는 방식을 비동기적이라고 하며 이러한 비동기 프로그래밍은 RxJava, Reactive와 같은 서드파티 라이브러리에서 제공한다.

#### 서드 파티 라이브러리?

보통 기본으로 제공되는 표준 라이브러리가 아닌 다른 개발자가 만든 라이브러리를 말한다. 개발을 편리하게 해 주는 플러그인, 프레임워크, 유틸리티 API 등을 제공한다.

코틀린에서는 코루틴을 서드파티가 아닌 기본으로 제공한다. 하나으이 개별적인 작업을 루틴이라고 부르는데 코루틴이란 여러 개의 루틴들이 협력한다는 의미로 만들어진 합성어이다.

순차적으로 루틴을 실행하는 동기 코드는 코드의 복잡도가 낮다. 하지만 코드의 여러 구간에서 요청된 작업이 마무리가 될 때 까지 멈춰있는 현상이 나타나게 된다 -> `블로킹된 코드`라고한다 블로킹된 코드를 개선하고 성능을 향상하려면 넌블로킹 기법의 코드를 구성해야 한다. 보통 다중 작업을하려면 스레드와 같은 비동기 코드를 작성해야 하는데 이 때 코드가 복잡해진다. 하지만 코루틴을 사용하면 넌블로킹 또는 비동기 코드를 마치 동기 코드처럼 쉽게 작성하면서도 비동기 효과를 낼 수 있다.

---

### 블로킹

![스크린샷 2022-02-07 오후 2.44.37](/Users/chan/Desktop/스크린샷 2022-02-07 오후 2.44.37.png)

다음은 2개의 태스크가 있는 일반적인 형태의 프로그램 흐름이다. 먼저 태스크 A에서 블로킹 구간을 발견할 수 있다. 태스크 A의 코드가 더 이상 진행되지 않고 내부 메모리 영역에서 해당 작업이 마무리될 때 까지 코드는 멈추게 된다. -> 해당 상황을 블로킹라고 한다.  우선 순위가 낮은 또 다른 태스크 B가 실행될 수 있다. 이때 우선순위가 높은 태스크 A의 실행이 재개되면 우선순위가 낮은 태스크 B는 블로킹하고 태스크 A가 종료되면 다시 태스크 B가 재개된다.

---

### 넌블로킹

![스크린샷 2022-02-07 오후 2.44.44](/Users/chan/Desktop/스크린샷 2022-02-07 오후 2.44.44.png)

태스크 A를 수행하는 도중에 또 다른 태스크 B가 생성될 수 있는데 이때 태스크 A,B는 비동기적으로 수행될 수 있다. 이 경우 A,B의 실행 시점이 운영체제에 의해 결정되기 때문에 어떤 것이 어떻게 수행될지는 프로그래머가 알 수 없고 2개의 태스크 사이에 운영체제의 스케줄링 기법에 의해 결정된다. 위 다이어그램에서는 2개의 태스크가 동시에 수행되는 것처럼 보이나 프로세서 코어 수에 따라 동시에 수행될 수도 있고 2개의 태스크를 자주 교환해 동시에 수행되는 것처럼 보이게 할 수있다. 여러 개의 코어가 태스크가 동시에 수행되는 것을 병행수행이라고 한다.

---

### 프로세스와 스레드

- 프로세스 : 하나의 프로그램이 실행되면 프로세스가 시작되는데 프로세스는 실행되는 메모리, 스택, 열린 파일 등을 모두 포함하기 때문에 프로세스 간 문맥 교환을 할 때 많은 비용이 든다.
- 스레드 : 자신의 스택만 독립적으로 가지고 나머지는대부분 스레드끼리 공유하므로 문맥 교환 비용이 낮아 프로그래밍에서 많이 사용된다. 다만 여러 개의 스레드를 구성하면 코드가 복잡해진다.

#### 문맥 교환이란?

- 하나의 프로세스나 스레드가 CPU를 사용하고 있는 상태에서 다른 프로세나 스레드가 CPU를 사용하도록 하기 위해, 이전의 프로세스의 상태를 보관하고 새로운 프로세스의 상태를 적재하는 과정을 말한다.
- 프로세스는 코드, 데이터, 열린 파일의 식별자, 동적 할당 영역, 스택 등을 가지고 있는데 이러한 것들을 문맥이라고 한다.
- 프로세스와 프로세스는 서로 완전히 독립되어 있어 프로세스 간의 실행을 전환하려면 이러한 문맥을 저장해 두었다가 새로운 프로세스의 문맥을 불러들이는 과정을 거치는 것이 문맥 교환이다.

---

## 코루틴

스레드와 같은 기법으로 구성하는 넌블로킹 코드는 성능이 뛰어나지만 코드가 복잡하여 안전하지 못한 코드를 만들 가능성이 높아진다. 코틀린은 코루틴을 통해 코드의 복잡성을 줄이고 손쉽게 일시 중단하거나 다시 시작하는 루틴을 만들어 낼 수있다.

### 코루틴의 기본 개념

프로세스나 스레는 해당 작업을 중단하고 다른 루틴을 실행하기 위한 문맥 교환을 시도할 때 많은 비용이 든다. 코루틴을 비용이 많이 드는 문맥 교환 없이 해당 루틴을 일시 중단해서 이러한 비용을 줄일 수 있다. 다르게 표현하면 운영체제가 스케줄링에 개입하는 과정이 필요하지 않다는 것이다. 또한 일시 중단은 사용자가 제어할 수 있다.

~~~kotlin
fun main() { // 메인 스레드 문맥
    GlobalScope.launch { // 새로운 코루틴을 백그라운드에 실행
        delay(1000L) // 1초의 넌블로킹 지연
        println("World!!") // 지연 후 출력
    }
    println("Hello,") // 메인스레드의 코루틴이 지연되는동안 계속 실행
    Thread.sleep(2000L) // 메인 스레드가 JVM에서 바로 종료되지 않게 2초 기다림
}
~~~

코루틴에서 사용되는 함수는 suspend( )로 선언된 지연 함수여야 코루틴 기능을 사용할 수 있다. suspend로 표기함으로서 이 함수는 일시 중단 될 수 있으며 필요한 경우 다시 재개할 수 있다. 만일 suspend 함수를 코루틴 블록 외에 오류가 생길 수 있다.

#### 중요!!

컴파일러는 suspend가 붙은 함수를 자동적으로 추출해 Continuation 클래스로부터 분리된 루틴을 만든다. 이러한 지연 함수는 코루틴 빌더인 launch와 async에서 사용할 수 있지만 메인 스레드에서는 사용할 수 없다. 지연 함수는 또 다른 지연 함수 내에서 사용하거나 코루틴 블록에서만 사용해야 한다.

### launch

launch를 통해 코루틴 블록을 만들어 내는 것이 코루틴 빌더의 생성이라고한다. launch를 살펴보면 실행 범위를 결정하는 GlobalScope가 지정되어 있다. 이것은 코루틴 생명 주기가 프로그램의 생명 주기에 의존되므로 main이 종료되면 같이 종료된다.

~~~kotlin
suspend fun work1(): String {
    delay(1000L)
    println("111")
    return "work1"
}

suspend fun work2(): String {
    delay(1000L)
    println("2222")
    return "work2"
}

private fun worksInSerial() {
    GlobalScope.launch {
        val one = work1()
        val two = work2()
        println("kotlin one : $one")
        println("kotlin two : $two")
    }
}

fun main() {
    worksInSerial()
    readLine()
}
~~~

launch에 정의된 work1(), work2() 함수는 순차적으로 표현할 수 있다. 2개의 함수는 내부적으로는 비동기 코드로 동시에 작동할 수 있지만 코드만 봤을 경우 순차적으로 실행되는 것처럼 표현함으로 프로그래밍의 복잡도를 낮추게 된다.

---

### async

async도 새로운 코루틴을 실행할 수 있다. launch와 다른 점은 Deferred<T>를 통해 결괏값을 반환한다는 것이다. 이때 지연된 결과값을 받기 위해 await()를 사용할 수 있다.

~~~kotlin
suspend fun async1(): String {
    delay(1000L)
    println("one")
    return "work1"
}

suspend fun async2(): String {
    delay(3000L)
    println("two")
    return "work2"
}

private fun worksInSerial() {
    val one = GlobalScope.async {
        async1()
    }
    val two = GlobalScope.async {
        async2()
    }

    GlobalScope.launch {
        val combined = one.await() + "_" + two.await()
        println("Kotlin combined : $combined")
    }
}

fun main() {
    worksInSerial()
    readLine()
}
~~~

async1( ), async2( )는 async에 의해 감싸져 있어 완전히 병행 수행할 수 있다. 여기서는 예측이 가능하지만 좀 더 복잡한 루틴을 작성하는 경우 어떤 루틴이 먼저 종료 될지 알기 어렵다. 따라서 태스크가 종료되는 시점을 기다렸다가 await( )를 사용해 현재 스레드의 블로킹 없이 먼저 종료되면 결과를 가져올 수 있다. await은 스레드를 방해하지 않고 deferred값이 계산될 때까지, 기다리게 하는 함수이다.

---
### 코루틴의 문맥

코루틴이 실행될 때 여러 가지 문맥은 CoroutineContext에 의해 정의된다. launch { ... }와 같이 인자가 없는 경우 CoroutineScope에서 상위의 문맥이 상속되어 결정되고 launch(Dispatchers.Default) { ... }와 같이 사용되면 GlobalScope에서 실행되는 문맥과 동일하게 사용된다. GlobalScope는 메인 스레드의 생명주기가 끝나면 같이 종료된다.

내부적으로 보통 CommonPool이 지정되어 코루틴이 사용할 스레드의 공동 풀을 사용하게 된다. 이것은 이미 초기화되어 있는 스레드 중 하나 혹은 그 이상이 선택되며 초기화하기 때문에 스레드를 생성하는 오버헤드가 없어 빠른 기법이다. 그리고 하나의 스레드에 다수의 코루틴이 동작할 수 있다. 만일 특정 스레드 개수를 직접 지정하려면 다음과 같이 사용자 문맥을 만들어 지정할 수 있다.

---

### 시작 시점에 대한 속성

- 필요한 경우 launch()나 async()에 인자를 지정해 코루틴에 필요한 속성을 줄 수 있다.

### launch( )

~~~kotlin
fun launch(
    context : CoroutineContext,
    start : CoroutineStart,
    parent : Job?,
    onCompletion : CompletionHandler?,
    block : suspend CoroutineScope.() -> Unit) : Job {   
  	...
}
~~~

context 매개변수 이외에도 start 매개변수를 지정할 수 있는데 CoroutineStart는 다음과 같이 정의 가능하다.

> - DEFAULT : 즉시 시작
> - LAZY : 코루틴을 느리게 시작 -> 처음에는 중단된 상태이며 start(), await() 등으로 시작한다.
> - ATOMIC : 최적화된 방법으로 시작
> - UNDISPATCHED : 분산 처리 방법으로 시작

---

### runBlock 사용

runBlocking은 새로운 코루틴을 실행하고 완료되기 전까지 현재 스레드를 블로킹한다. runBlocking에서는 지연 함수를 사용할 수 있다.

~~~kotlin
fun main() = runBlocking { //main함수가 코루틴 환경에서 실행
    launch { //백그라운드로 코루틴 실행
        delay(1000L)
        println("World!!")
    }
    println("Hello!!") // 즉시 실행
}
~~~



